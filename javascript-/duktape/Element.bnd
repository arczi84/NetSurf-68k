/* document binding for browser using duktape and libdom
 *
 * Copyright 2015 Vincent Sanders <vince@netsurf-browser.org>
 *
 * This file is part of NetSurf, http://www.netsurf-browser.org/
 *
 * Released under the terms of the MIT License,
 *         http://www.opensource.org/licenses/mit-license
 */

class Element {
	prologue %{
%};
}

init Element("struct dom_element *" element::node);

getter Element::firstElementChild()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *next_node;

	exc = dom_node_get_first_child(((node_private_t*)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_next_sibling(element, &next_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = next_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::lastElementChild()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *next_node;

	exc = dom_node_get_last_child(((node_private_t*)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_previous_sibling(element, &next_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = next_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::previousElementSibling()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *sib_node;

	exc = dom_node_get_previous_sibling(((node_private_t *)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_previous_sibling(element, &sib_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = sib_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::nextElementSibling()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *sib_node;

	exc = dom_node_get_next_sibling(((node_private_t *)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			/* found it */
			dukky_push_node(ctx, (dom_node *)element);
			dom_node_unref(element);
			return 1;
		}

		exc = dom_node_get_next_sibling(element, &sib_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = sib_node;
		} else {
			element = NULL;
		}
	}
	return 0;
%}

getter Element::childElementCount()
%{
	dom_node *element;
	dom_exception exc;
	dom_node_type node_type;
	dom_node *next_node;
	duk_uint_t jsret = 0;

	exc = dom_node_get_first_child(((node_private_t *)priv)->node, &element);
	if (exc != DOM_NO_ERR) {
		return 0;
	}

	while (element != NULL) {
		exc = dom_node_get_node_type(element, &node_type);
		if ((exc == DOM_NO_ERR) && (node_type == DOM_ELEMENT_NODE)) {
			jsret += 1;
		}

		exc = dom_node_get_next_sibling(element, &next_node);
		dom_node_unref(element);
		if (exc == DOM_NO_ERR) {
			element = next_node;
		} else {
			element = NULL;
		}
	}
	LOG("I found %u of them", jsret);
	duk_push_uint(ctx, jsret);
	return 1;
%}

method Element::getElementsByTagName ()
%{
	dom_nodelist *nlist = NULL;
	dom_exception exc;
	dom_string *tagname;
	duk_size_t len;
	const char *str = duk_to_lstring(ctx, 0, &len);

	exc = dom_string_create((const uint8_t *)str, len, &tagname);

	if (exc != DOM_NO_ERR) return 0;

	exc = dom_element_get_elements_by_tag_name(priv->parent.node,
						   tagname, &nlist);
	dom_string_unref(tagname);
	if (exc != DOM_NO_ERR) return 0;
	duk_push_pointer(ctx, nlist);
	dukky_create_object(ctx, PROTO_NAME(NODELIST), 1);
	dom_nodelist_unref(nlist);

	return 1;
%}
